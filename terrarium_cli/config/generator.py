"""
Configuration generator for Docker Compose and K3s manifests.
"""

import yaml
import logging
from pathlib import Path
from typing import List, Dict, Any
from jinja2 import Environment, FileSystemLoader

from terrarium_cli.config.app_loader import AppConfig
from terrarium_cli.config.nginx_generator import NginxConfigGenerator
from terrarium_cli.config.global_config import load_global_config

logger = logging.getLogger(__name__)

# Constants
AUTO_GENERATED_WARNING = """# =============================================================================
# AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
# =============================================================================
# This file is automatically generated by the Terrarium CLI from templates.
# Any manual changes will be overwritten on the next deployment.
# 
# To modify the configuration, edit the app-config.yml files in the apps/ directory
# or update the templates in terrarium_cli/templates/
# =============================================================================

"""

# App categories for service grouping
# Note: These are fallback categories. The actual categorization is dynamic based on app names.
CORE_APPS = ["logthon", "file-storage"]
APP_APPS = ["custom-client", "service-sink"]
GATEWAY_APPS = ["nginx"]


class ConfigGenerator:
    """Generates Docker Compose and K3s configurations from app configs."""
    
    def __init__(self):
        """Initialize the configuration generator."""
        self.templates_dir = Path("terrarium_cli/templates")
        self.configs_dir = Path("configs")
        self.jinja_env = Environment(loader=FileSystemLoader(self.templates_dir))
        
        # Add base64encode filter
        import base64
        self.jinja_env.filters['base64encode'] = lambda x: base64.b64encode(x.encode('utf-8')).decode('utf-8')
        
        self.global_config = load_global_config()
        
        # Initialize NGINX config generator
        self.nginx_generator = NginxConfigGenerator()
    
    def _ensure_directory_exists(self, directory: Path) -> None:
        """Ensure directory exists, creating it if necessary."""
        directory.mkdir(parents=True, exist_ok=True)
    
    def _cleanup_generated_files(self, config_dir: Path) -> None:
        """
        Clean up auto-generated files before creating new ones.
        
        Args:
            config_dir: Directory to clean up
        """
        logger.info(f"Cleaning up generated files in {config_dir}")
        
        # Define patterns for auto-generated files
        patterns_to_remove = [
            # Docker Compose files
            "docker-compose*.yml",
            "nginx/*.conf",
            "nginx/*.template",
            
            # K3s manifest files
            "*-deployment.yaml",
            "*-service.yaml", 
            "*-pvc.yaml",
            "*-configmap.yaml",
            "*-secret.yaml",
            "ingress.yaml",
            "nginx-ingress-controller.yaml",
            "kustomization.yaml",
            "namespace.yaml"
        ]
        
        # Remove files matching patterns
        for pattern in patterns_to_remove:
            for file_path in config_dir.glob(pattern):
                if file_path.is_file():
                    try:
                        file_path.unlink()
                        logger.debug(f"Removed: {file_path}")
                    except OSError as e:
                        logger.warning(f"Failed to remove {file_path}: {e}")
        
        # Clean up subdirectories that might be empty
        for subdir in config_dir.iterdir():
            if subdir.is_dir() and subdir.name in ["nginx"]:
                try:
                    # Remove all files in subdirectory
                    for file_path in subdir.glob("*"):
                        if file_path.is_file():
                            file_path.unlink()
                            logger.debug(f"Removed: {file_path}")
                except OSError as e:
                    logger.warning(f"Failed to clean subdirectory {subdir}: {e}")
    
    def _write_yaml_file_with_warning(self, file_path: Path, data: Dict[str, Any]) -> None:
        """Write YAML file with auto-generated warning comment."""
        with open(file_path, 'w') as f:
            f.write(AUTO_GENERATED_WARNING)
            yaml.dump(data, f, default_flow_style=False, sort_keys=False)
    
    def _render_template(self, template_name: str, **kwargs) -> str:
        """Render a Jinja2 template with the given context."""
        template = self.jinja_env.get_template(template_name)
        return template.render(**kwargs)
    
    def _write_template_file(self, file_path: Path, template_name: str, **kwargs) -> None:
        """Write a template-rendered file."""
        content = self._render_template(template_name, **kwargs)
        with open(file_path, 'w') as f:
            f.write(content)
    
    def _filter_apps_by_category(self, apps: List[AppConfig], category: List[str]) -> List[AppConfig]:
        """Filter apps by category."""
        return [app for app in apps if app.name in category]
    
    def _categorize_apps(self, apps: List[AppConfig]) -> Dict[str, List[AppConfig]]:
        """Dynamically categorize apps based on their names and characteristics."""
        categories = {
            "core": [],
            "apps": [],
            "gateway": [],
            "other": []
        }
        
        for app in apps:
            # Skip nginx as it's handled separately
            if app.name == "nginx":
                categories["gateway"].append(app)
            # Check if it's a known core app
            elif app.name in CORE_APPS:
                categories["core"].append(app)
            # Check if it's a known app
            elif app.name in APP_APPS:
                categories["apps"].append(app)
            # For any new/unknown apps, categorize based on naming patterns
            elif app.name in ["vault"]:
                # Vault is special - it goes in core for now
                categories["core"].append(app)
            else:
                # New apps default to the "apps" category
                categories["apps"].append(app)
        
        return categories
    
    def generate_all_configs(self, apps: List[AppConfig]) -> None:
        """Generate all configuration files including NGINX."""
        # Clean up existing generated files first
        self._cleanup_generated_files(self.configs_dir / "docker")
        self._cleanup_generated_files(self.configs_dir / "k3s")
        
        # Generate NGINX configurations first
        self.nginx_generator.generate_configs()
        
        # Generate Docker Compose and K3s configurations
        self.generate_docker_compose(apps)
        self.generate_k3s_manifests(apps)
        
        # Generate kustomization.yaml dynamically
        self._generate_kustomization(self.configs_dir / "k3s", apps)
    
    def generate_docker_compose(self, apps: List[AppConfig]) -> None:
        """
        Generate Docker Compose configuration.
        
        Args:
            apps: List of app configurations
        """
        logger.info("Generating Docker Compose configuration")
        
        # Create configs directory if it doesn't exist
        docker_config_dir = self.configs_dir / "docker"
        self._ensure_directory_exists(docker_config_dir)
        
        # Generate main docker-compose.yml
        self._generate_main_docker_compose(docker_config_dir, apps)
        
        # Generate individual compose files
        self._generate_docker_compose_files(docker_config_dir, apps)
        
        # Generate NGINX configuration
        self._generate_nginx_config(docker_config_dir, apps)
    
    def generate_k3s_manifests(self, apps: List[AppConfig]) -> None:
        """
        Generate K3s manifests.
        
        Args:
            apps: List of app configurations
        """
        logger.info("Generating K3s manifests")
        
        # Create configs directory if it doesn't exist
        k3s_config_dir = self.configs_dir / "k3s"
        self._ensure_directory_exists(k3s_config_dir)
        
        # Generate namespace
        self._generate_namespace(k3s_config_dir)
        
        # Generate deployments
        for app in apps:
            self._generate_deployment(k3s_config_dir, app)
            self._generate_service(k3s_config_dir, app)
            if app.volumes:
                self._generate_pvc(k3s_config_dir, app)
            
            # Generate database deployments and services
            for db_config in app.databases:
                if db_config.enabled:
                    self._generate_database_deployment(k3s_config_dir, app, db_config)
                    self._generate_database_service(k3s_config_dir, app, db_config)
                    self._generate_database_pvc(k3s_config_dir, app, db_config)
                    self._generate_database_configmap(k3s_config_dir, app, db_config)
                    self._generate_database_secret(k3s_config_dir, app, db_config)
        
        # Generate NGINX configuration
        self._generate_nginx_k3s_config(k3s_config_dir, apps)
        
        # Generate kustomization
        self._generate_kustomization(k3s_config_dir, apps)
    
    def _generate_main_docker_compose(self, config_dir: Path, apps: List[AppConfig]) -> None:
        """Generate main docker-compose.yml file."""
        compose_file = config_dir / "docker-compose.yml"
        self._write_template_file(compose_file, 'docker-compose.yml.j2', 
                                apps=apps, global_config=self.global_config)
    
    def _generate_docker_compose_files(self, config_dir: Path, apps: List[AppConfig]) -> None:
        """Generate individual Docker Compose files."""
        # Base services (Vault)
        base_services = self._generate_vault_services()
        self._write_compose_file(config_dir / "docker-compose.base.yml", base_services)
        
        # Core services (Logthon, File Storage)
        core_services = self._generate_core_services(apps)
        self._write_compose_file(config_dir / "docker-compose.core.yml", core_services)
        
        # App services (Custom Client, Service Sink)
        app_services = self._generate_app_services(apps)
        self._write_compose_file(config_dir / "docker-compose.apps.yml", app_services)
        
        # Gateway services (NGINX)
        gateway_services = self._generate_gateway_services(apps)
        self._write_compose_file(config_dir / "docker-compose.gateway.yml", gateway_services)
        
        # Database services
        database_services = self._generate_database_services(apps)
        self._write_compose_file(config_dir / "docker-compose.databases.yml", database_services)
    
    def _generate_vault_services(self) -> Dict[str, Any]:
        """Generate Vault services configuration."""
        return {
            "services": {
                "vault": {
                    "image": "hashicorp/vault:latest",
                    "container_name": "edge-terrarium-vault",
                    "ports": ["8200:8200"],
                    "environment": [
                        "VAULT_DEV_ROOT_TOKEN_ID=root",
                        "VAULT_DEV_LISTEN_ADDRESS=0.0.0.0:8200",
                        "VAULT_ADDR=http://0.0.0.0:8200"
                    ],
                    "volumes": ["vault-data:/vault/data"],
                    "networks": ["edge-terrarium-network"],
                    "restart": "unless-stopped",
                    "healthcheck": {
                        "test": ["CMD", "vault", "status"],
                        "interval": "30s",
                        "timeout": "10s",
                        "retries": 3,
                        "start_period": "40s"
                    }
                },
                "vault-init": {
                    "image": "hashicorp/vault:latest",
                    "container_name": "edge-terrarium-vault-init",
                    "depends_on": {
                        "vault": {"condition": "service_healthy"}
                    },
                    "volumes": ["./vault-init.sh:/vault-init.sh:ro"],
                    "command": ["/bin/sh", "/vault-init.sh"],
                    "networks": ["edge-terrarium-network"],
                    "restart": "no"
                }
            }
        }
    
    def _generate_core_services(self, apps: List[AppConfig]) -> Dict[str, Any]:
        """Generate core services configuration."""
        categories = self._categorize_apps(apps)
        services = {app.name: self._generate_docker_service(app) for app in categories["core"]}
        return {"services": services}
    
    def _generate_app_services(self, apps: List[AppConfig]) -> Dict[str, Any]:
        """Generate app services configuration."""
        categories = self._categorize_apps(apps)
        services = {app.name: self._generate_docker_service(app) for app in categories["apps"]}
        return {"services": services}
    
    def _generate_gateway_services(self, apps: List[AppConfig]) -> Dict[str, Any]:
        """Generate gateway services configuration."""
        categories = self._categorize_apps(apps)
        if not categories["gateway"]:
            return {"services": {}}
        
        services = {app.name: self._generate_docker_service(app) for app in categories["gateway"]}
        return {"services": services}
    
    def _generate_docker_service(self, app: AppConfig) -> Dict[str, Any]:
        """Generate Docker service configuration for an app."""
        # Collect environment variables
        env_vars = []
        
        # Add regular environment variables
        for env in app.environment:
            if env.value:
                env_vars.append(f"{env.name}={env.value}")
            elif env.value_from:
                # Handle Vault references
                if env.value_from.startswith("vault:"):
                    # For Docker, we'll use the actual value from Vault
                    # This would need to be resolved at runtime
                    env_vars.append(f"{env.name}=${{{env.name}}}")
                else:
                    env_vars.append(f"{env.name}={env.value_from}")
        
        # Add database environment variables
        from terrarium_cli.utils.database import get_database_environment_variables
        for db_config in app.databases:
            if db_config.enabled:
                # Generate mock credentials for Docker Compose
                mock_credentials = {
                    "host": f"{app.name}-db",
                    "port": "5432",
                    "username": f"{app.name}_user",
                    "password": "generated_password",  # This would be resolved at runtime
                    "database_name": db_config.name,
                    "url": f"postgresql://{app.name}_user:generated_password@{app.name}-db:5432/{db_config.name}"
                }
                
                db_env_vars = get_database_environment_variables(app.name, db_config, mock_credentials)
                for db_env in db_env_vars:
                    if db_env.get("value"):
                        env_vars.append(f"{db_env['name']}={db_env['value']}")
                    elif db_env.get("value_from"):
                        env_vars.append(f"{db_env['name']}=${{{db_env['name']}}}")
        
        service = {
            "build": {
                "context": f"../../apps/{app.name}",
                "dockerfile": app.docker.dockerfile
            },
            "image": f"{app.docker.image_name}:{app.docker.tag}",
            "container_name": f"edge-terrarium-{app.name}",
            "ports": [f"{app.runtime.port}:{app.runtime.port}"],
            "environment": env_vars,
            "networks": ["edge-terrarium-network"],
            "restart": "unless-stopped"
        }
        
        # Add health check
        if app.health_checks:
            health_check = list(app.health_checks.values())[0]
            service["healthcheck"] = {
                "test": ["CMD", "curl", "-f", f"http://localhost:{health_check.port}{health_check.path}"],
                "interval": f"{health_check.period_seconds}s",
                "timeout": f"{health_check.timeout_seconds}s",
                "retries": health_check.failure_threshold,
                "start_period": "5s"
            }
        
        # Add volumes
        if app.volumes:
            service["volumes"] = [f"{vol.name}:{vol.mount_path}" for vol in app.volumes]
        
        # Add dependencies
        if app.dependencies:
            service["depends_on"] = {dep: {"condition": "service_healthy"} for dep in app.dependencies}
        
        return service
    
    def _generate_database_services(self, apps: List[AppConfig]) -> Dict[str, Any]:
        """Generate database services for all apps."""
        services = {}
        
        for app in apps:
            for db_config in app.databases:
                if db_config.enabled:
                    service_name = f"{app.name}-db"
                    services[service_name] = self._generate_docker_database_service(app, db_config)
        
        return {"services": services}
    
    def _generate_docker_database_service(self, app: AppConfig, db_config) -> Dict[str, Any]:
        """Generate Docker service configuration for a database."""
        service_name = f"{app.name}-db"
        
        # Port mapping
        ports = ["5432:5432"]
        if db_config.port_forward:
            ports = [f"{db_config.port_forward}:5432"]
        
        service = {
            "image": f"postgres:{db_config.version}",
            "container_name": f"edge-terrarium-{service_name}",
            "ports": ports,
            "environment": [
                f"POSTGRES_DB={db_config.name}",
                f"POSTGRES_USER={app.name}_user",
                f"POSTGRES_PASSWORD=$${{{app.name.upper()}_DB_PASSWORD}}",
                "POSTGRES_INITDB_ARGS=--auth-host=scram-sha-256"
            ],
            "volumes": [
                f"{service_name}-data:/var/lib/postgresql/data"
            ],
            "networks": ["edge-terrarium-network"],
            "restart": "unless-stopped",
            "healthcheck": {
                "test": ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"],
                "interval": "30s",
                "timeout": "10s",
                "retries": 3,
                "start_period": "40s"
            }
        }
        
        # Add initialization scripts if specified
        if db_config.init_scripts:
            init_volume_mounts = []
            for script in db_config.init_scripts:
                init_volume_mounts.append(f"../../apps/{app.name}/{script}:/docker-entrypoint-initdb.d/{script.split('/')[-1]}:ro")
            service["volumes"].extend(init_volume_mounts)
        
        return service
    
    def _generate_docker_volumes(self, apps: List[AppConfig]) -> Dict[str, Any]:
        """Generate Docker volumes configuration."""
        volumes = {}
        
        for app in apps:
            for volume in app.volumes:
                volumes[volume.name] = {"driver": "local"}
        
        # Add database volumes
        for app in apps:
            for db_config in app.databases:
                if db_config.enabled:
                    service_name = f"{app.name}-db"
                    volumes[f"{service_name}-data"] = {"driver": "local"}
        
        # Add standard volumes
        volumes.update({
            "vault-data": {"driver": "local"},
            "vault-logs": {"driver": "local"}
        })
        
        return volumes
    
    def _write_compose_file(self, file_path: Path, data: Dict[str, Any]) -> None:
        """Write Docker Compose file."""
        self._write_yaml_file_with_warning(file_path, data)
    
    def _generate_nginx_config(self, config_dir: Path, apps: List[AppConfig]) -> None:
        """Generate NGINX configuration."""
        nginx_dir = config_dir / "nginx"
        self._ensure_directory_exists(nginx_dir)
        
        # Generate upstreams and routes
        upstreams = []
        routes = []
        
        for app in apps:
            if app.name == "nginx":
                continue
                
            upstreams.append({
                "name": app.name,
                "host": app.name,
                "port": app.runtime.port
            })
            
            for route in app.routes:
                routes.append({
                    "path": route.path,
                    "upstream": app.name,
                    "strip_prefix": route.strip_prefix
                })
        
        # Generate NGINX config using template
        template_data = {
            "upstreams": upstreams,
            "routes": routes
        }
        
        # Load template
        template_file = Path("terrarium_cli/templates/nginx.conf.template")
        if template_file.exists():
            with open(template_file, 'r') as f:
                from jinja2 import Template
                template = Template(f.read())
            
            nginx_config = template.render(**template_data)
            
            with open(nginx_dir / "default.conf", 'w') as f:
                f.write(nginx_config)
    
    def _generate_namespace(self, config_dir: Path) -> None:
        """Generate namespace manifest."""
        namespace_data = {
            "apiVersion": "v1",
            "kind": "Namespace",
            "metadata": {
                "name": "edge-terrarium",
                "labels": {
                    "name": "edge-terrarium",
                    "project": "edge-terrarium"
                }
            }
        }
        
        self._write_yaml_file_with_warning(config_dir / "namespace.yaml", namespace_data)
    
    def _generate_deployment(self, config_dir: Path, app: AppConfig) -> None:
        """Generate deployment manifest for an app."""
        deployment_file = config_dir / f"{app.name}-deployment.yaml"
        self._write_template_file(deployment_file, 'k3s-deployment.yaml.j2', 
                                app=app, global_config=self.global_config)
    
    def _generate_container_spec(self, app: AppConfig) -> Dict[str, Any]:
        """Generate container specification."""
        container = {
            "name": app.name,
            "image": f"{app.docker.image_name}:{app.docker.tag}",
            "ports": [{
                "containerPort": app.runtime.port,
                "name": "http"
            }],
            "env": []
        }
        
        # Add environment variables
        for env_var in app.environment:
            if env_var.value:
                container["env"].append({
                    "name": env_var.name,
                    "value": env_var.value
                })
            elif env_var.value_from:
                if env_var.value_from.startswith("vault:"):
                    # Handle Vault references for K3s
                    container["env"].append({
                        "name": env_var.name,
                        "valueFrom": {
                            "secretKeyRef": {
                                "name": f"{app.name}-secrets",
                                "key": env_var.value_from.split("#")[1] if "#" in env_var.value_from else env_var.name.lower()
                            }
                        }
                    })
                else:
                    container["env"].append({
                        "name": env_var.name,
                        "valueFrom": {
                            "fieldRef": {
                                "fieldPath": env_var.value_from
                            }
                        }
                    })
        
        # Add database environment variables
        from terrarium_cli.utils.database import get_database_environment_variables
        for db_config in app.databases:
            if db_config.enabled:
                # Generate mock credentials for K3s
                mock_credentials = {
                    "host": f"{app.name}-db",
                    "port": "5432",
                    "username": f"{app.name}_user",
                    "password": "generated_password",  # This would be resolved at runtime
                    "database_name": db_config.name,
                    "url": f"postgresql://{app.name}_user:generated_password@{app.name}-db:5432/{db_config.name}"
                }
                
                db_env_vars = get_database_environment_variables(app.name, db_config, mock_credentials)
                for db_env in db_env_vars:
                    if db_env.get("value"):
                        container["env"].append({
                            "name": db_env["name"],
                            "value": db_env["value"]
                        })
                    elif db_env.get("value_from"):
                        if db_env["value_from"].startswith("vault:"):
                            container["env"].append({
                                "name": db_env["name"],
                                "valueFrom": {
                                    "secretKeyRef": {
                                        "name": f"{app.name}-secrets",
                                        "key": db_env["value_from"].split("#")[1] if "#" in db_env["value_from"] else db_env["name"].lower()
                                    }
                                }
                            })
                        else:
                            container["env"].append({
                                "name": db_env["name"],
                                "valueFrom": {
                                    "fieldRef": {
                                        "fieldPath": db_env["value_from"]
                                    }
                                }
                            })
        
        # Add health checks
        if app.health_checks:
            for check_name, check_config in app.health_checks.items():
                if check_name == "liveness":
                    container["livenessProbe"] = {
                        "httpGet": {
                            "path": check_config.path,
                            "port": check_config.port
                        },
                        "periodSeconds": check_config.period_seconds,
                        "timeoutSeconds": check_config.timeout_seconds,
                        "failureThreshold": check_config.failure_threshold
                    }
                elif check_name == "readiness":
                    container["readinessProbe"] = {
                        "httpGet": {
                            "path": check_config.path,
                            "port": check_config.port
                        },
                        "periodSeconds": check_config.period_seconds,
                        "timeoutSeconds": check_config.timeout_seconds,
                        "failureThreshold": check_config.failure_threshold
                    }
        
        # Add resources
        container["resources"] = {
            "requests": {
                "cpu": app.resources.cpu["request"],
                "memory": app.resources.memory["request"]
            },
            "limits": {
                "cpu": app.resources.cpu["limit"],
                "memory": app.resources.memory["limit"]
            }
        }
        
        # Add security context
        container["securityContext"] = {
            "runAsNonRoot": app.security.run_as_non_root,
            "runAsUser": app.security.run_as_user,
            "runAsGroup": app.security.run_as_group,
            "allowPrivilegeEscalation": app.security.allow_privilege_escalation,
            "readOnlyRootFilesystem": app.security.read_only_root_filesystem
        }
        
        # Add volume mounts
        if app.volumes:
            container["volumeMounts"] = [
                {
                    "name": vol.name,
                    "mountPath": vol.mount_path
                }
                for vol in app.volumes
            ]
        
        return container
    
    def _generate_service(self, config_dir: Path, app: AppConfig) -> None:
        """Generate service manifest for an app."""
        service_file = config_dir / f"{app.name}-service.yaml"
        self._write_template_file(service_file, 'k3s-service.yaml.j2', 
                                app=app, global_config=self.global_config)
    
    def _generate_pvc(self, config_dir: Path, app: AppConfig) -> None:
        """Generate PVC manifest for an app."""
        if app.volumes:
            pvc_file = config_dir / f"{app.name}-pvc.yaml"
            self._write_template_file(pvc_file, 'k3s-pvc.yaml.j2', 
                                    apps=[app], global_config=self.global_config)
    
    def _generate_nginx_k3s_config(self, config_dir: Path, apps: List[AppConfig]) -> None:
        """Generate NGINX configuration for K3s."""
        ingress_file = config_dir / "ingress.yaml"
        self._write_template_file(ingress_file, 'k3s-ingress.yaml.j2', 
                                apps=apps, global_config=self.global_config)
    
    def _generate_kustomization(self, config_dir: Path, apps: List[AppConfig]) -> None:
        """Generate kustomization.yaml file dynamically based on available resources."""
        resources = [
            "namespace.yaml",
            "nginx-configmap.yaml"  # NGINX ConfigMap is always needed
        ]
        
        # Add app-specific resources (this includes nginx, vault, etc.)
        for app in apps:
            resources.append(f"{app.name}-deployment.yaml")
            resources.append(f"{app.name}-service.yaml")
            if app.volumes:
                resources.append(f"{app.name}-pvc.yaml")
            
            # Add database resources
            for db_config in app.databases:
                if db_config.enabled:
                    resources.append(f"{app.name}-db-deployment.yaml")
                    resources.append(f"{app.name}-db-service.yaml")
                    resources.append(f"{app.name}-db-pvc.yaml")
                    resources.append(f"{app.name}-db-secret.yaml")
                    resources.append(f"{app.name}-db-configmap.yaml")
        
        # Add ingress resources
        resources.extend([
            "ingress.yaml"
        ])
        
        # Add NGINX ingress controller if it exists
        nginx_ingress_file = config_dir / "nginx-ingress-controller.yaml"
        if nginx_ingress_file.exists():
            resources.append("nginx-ingress-controller.yaml")
        
        # Note: Logthon-specific ingress resources are handled by the main ingress.yaml
        
        kustomization_data = {
            "apiVersion": "kustomize.config.k8s.io/v1beta1",
            "kind": "Kustomization",
            "resources": resources
        }
        
        self._write_yaml_file_with_warning(config_dir / "kustomization.yaml", kustomization_data)
    
    def _generate_database_deployment(self, config_dir: Path, app: AppConfig, db_config) -> None:
        """Generate database deployment manifest for K3s."""
        deployment_file = config_dir / f"{app.name}-db-deployment.yaml"
        self._write_template_file(deployment_file, 'k3s-database-deployment.yaml.j2', 
                                app=app, db_config=db_config, global_config=self.global_config)
    
    def _generate_database_service(self, config_dir: Path, app: AppConfig, db_config) -> None:
        """Generate database service manifest for K3s."""
        service_file = config_dir / f"{app.name}-db-service.yaml"
        self._write_template_file(service_file, 'k3s-database-service.yaml.j2', 
                                app=app, db_config=db_config, global_config=self.global_config)
    
    def _generate_database_pvc(self, config_dir: Path, app: AppConfig, db_config) -> None:
        """Generate database PVC manifest for K3s."""
        pvc_file = config_dir / f"{app.name}-db-pvc.yaml"
        self._write_template_file(pvc_file, 'k3s-database-pvc.yaml.j2', 
                                app=app, db_config=db_config, global_config=self.global_config)
    
    def _generate_database_configmap(self, config_dir: Path, app: AppConfig, db_config) -> None:
        """Generate database ConfigMap manifest for init scripts."""
        if not db_config.init_scripts:
            return
            
        # Read init script files
        init_scripts = {}
        for script_path in db_config.init_scripts:
            script_file = Path(f"apps/{app.name}/{script_path}")
            if script_file.exists():
                with open(script_file, 'r') as f:
                    script_content = f.read()
                script_name = script_path.split('/')[-1]
                init_scripts[script_name] = script_content
            else:
                print(f"Warning: Init script not found: {script_file}")
        
        if not init_scripts:
            return
            
        configmap_file = config_dir / f"{app.name}-db-configmap.yaml"
        self._write_template_file(configmap_file, 'k3s-database-configmap.yaml.j2', 
                                app=app, db_config=db_config, global_config=self.global_config,
                                init_scripts=init_scripts)
    
    def _generate_database_secret(self, config_dir: Path, app: AppConfig, db_config) -> None:
        """Generate database Secret manifest for credentials."""
        from terrarium_cli.utils.database import DatabaseManager
        
        # Generate database credentials
        db_manager = DatabaseManager()
        credentials = db_manager.generate_database_credentials(app.name, db_config)
        
        # Update host to use simplified name for K3s
        credentials["host"] = f"{app.name}-db"
        credentials["url"] = f"postgresql://{credentials['username']}:{credentials['password']}@{credentials['host']}:{credentials['port']}/{credentials['database_name']}"
        
        secret_file = config_dir / f"{app.name}-db-secret.yaml"
        self._write_template_file(secret_file, 'k3s-database-secret.yaml.j2', 
                                app=app, db_config=db_config, global_config=self.global_config,
                                credentials=credentials)
