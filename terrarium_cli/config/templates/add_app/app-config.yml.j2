# =============================================================================
# {{ app_name.title() }} Application Configuration
# =============================================================================
# This file defines how the application is deployed and configured in both 
# Docker Compose and Kubernetes (K3s) environments. It serves as the single
# source of truth for application deployment settings.
#
# Template Variables:
#   {{ app_name }} - The name of the application
#   {{ app_description }} - Description of what the application does
#   {{ image_name }} - Docker image name (will be prefixed with edge-terrarium-)
#   {{ port }} - Internal port the application listens on
#   {{ environment_vars }} - List of environment variables
#   {{ routes }} - List of API routes this app handles
#   {{ volumes }} - List of persistent volumes
#
# Important Notes:
#   - The /api/ prefix is automatically added by the ingress layer (NGINX)
#   - Routes should be defined WITHOUT the /api/ prefix
#   - All settings apply to both Docker and K3s deployments
#   - This file is processed by the terrarium CLI tool
# =============================================================================

# =============================================================================
# BASIC APPLICATION INFORMATION
# =============================================================================
# These fields identify and describe the application

# Application name - must be unique across all apps
# Used for container names, service names, and resource naming
name: {{ app_name }}

# Human-readable description of what this application does
# Used in documentation and deployment logs
description: {{ app_description }}

# =============================================================================
# DOCKER CONFIGURATION
# =============================================================================
# These settings control how the application is built and containerized
# All Docker-related settings are defined here

docker:
  # Build context directory relative to the app directory
  # Usually "." for the current directory, but can be a subdirectory
  build_context: .                    
  
  # Name of the Dockerfile to use for building
  # Can be "Dockerfile" or a custom name like "Dockerfile.prod"
  dockerfile: Dockerfile              
  
  # Docker image name (will be prefixed with edge-terrarium-)
  # Final image name will be: edge-terrarium-{{ image_name }}
  image_name: {{ image_name }}        
  
  # Docker image tag to use
  # "latest" is the default, but you can use version tags like "v1.0.0"
  tag: latest                         

# =============================================================================
# RUNTIME CONFIGURATION
# =============================================================================
# These settings control how the application runs inside containers
# Both Docker Compose and Kubernetes use these settings

runtime:
  # Internal port the application listens on inside the container
  # This should match the port your application actually uses
  port: {{ port }}                    
  
  # Health check endpoint path
  # Your application should respond to GET /health with HTTP 200
  health_check_path: /health          
  
  # Maximum time (seconds) to wait for app to start before considering it failed
  # Useful for applications that take time to initialize
  startup_timeout: 30                 

# =============================================================================
# ENVIRONMENT VARIABLES
# =============================================================================
# These variables are passed to the application at runtime
# Can include both static values and references to Vault secrets

environment:
{% if environment_vars %}
{% for env in environment_vars %}
  # Environment variable: {{ env.name }}
  # Value: {{ env.value }}
  - name: {{ env.name }}
    value: {{ env.value }}
{% endfor %}
{% else %}
  # No environment variables configured
  # Add variables like this:
  # - name: DATABASE_URL
  #   value: "postgresql://user:pass@localhost/db"
  # - name: API_KEY
  #   value_from: "vault:secret/myapp#api_key"
{% endif %}

# =============================================================================
# ROUTING CONFIGURATION
# =============================================================================
# Define how external requests are routed to this application
# The /api/ prefix is automatically added by NGINX for path-based routes
# 
# Route Matching Rules:
#   - Routes are matched by priority (higher number = higher priority)
#   - Then by specificity (most specific path first)
#   - strip_prefix: true removes the matched path before forwarding to the app
#   - strip_prefix: false forwards the full path including the matched portion
#   - host: specify a hostname for host-based routing (optional)
#   - priority: route priority, higher numbers take precedence (default: 0)
#
# Examples:
#   Path-based routing: /api/myapp/* -> this app
#   Host-based routing: mycoolwebsite.company.com/* -> this app
#   Mixed routing: mycoolwebsite.company.com/api/special/* -> this app

routes:
{% if routes %}
{% for route in routes %}
  # Route: {{ route.path }}{% if route.host %} (host: {{ route.host }}){% endif %} -> {{ route.target }}
  # Strip prefix: {{ route.strip_prefix | lower }}
{% if route.priority %}  # Priority: {{ route.priority }}
{% endif %}  - path: {{ route.path }}
    target: {{ route.target }}
    strip_prefix: {{ route.strip_prefix | lower }}
{% if route.host %}    host: {{ route.host }}
{% endif %}{% if route.priority %}    priority: {{ route.priority }}
{% endif %}
{% endfor %}

  # =============================================================================
  # HOST-BASED ROUTING EXAMPLES (Commented for reference)
  # =============================================================================
  # Uncomment and modify these examples to add host-based routing:
  
  # # High priority route for custom domain - all paths
  # - path: /*
  #   target: /
  #   strip_prefix: false
  #   host: mycoolwebsite.company.com
  #   priority: 200
  #   description: "All requests to mycoolwebsite.company.com"
  
  # # API endpoints for custom domain
  # - path: /api/*
  #   target: /api/
  #   strip_prefix: true
  #   host: mycoolwebsite.company.com
  #   priority: 250
  #   description: "API endpoints for mycoolwebsite.company.com"
{% else %}
  # No routes configured
  # Add routes like this:
  
  # =============================================================================
  # PATH-BASED ROUTING (Traditional approach)
  # =============================================================================
  # Routes requests based on URL path patterns
  # External requests: https://edge-terrarium.local/api/{{ app_name }}/* -> this app
  
  # - path: /{{ app_name }}/*
  #   target: /
  #   strip_prefix: true
  #   priority: 100
  #   description: "Main application endpoint"
  
  # =============================================================================
  # HOST-BASED ROUTING (Advanced approach)
  # =============================================================================
  # Routes requests based on hostname, allowing multiple domains per deployment
  # External requests: https://mycoolwebsite.company.com/* -> this app
  
  # # High priority route for custom domain - all paths
  # - path: /*
  #   target: /
  #   strip_prefix: false
  #   host: mycoolwebsite.company.com
  #   priority: 200
  #   description: "All requests to mycoolwebsite.company.com"
  
  # # API endpoints for custom domain
  # - path: /api/*
  #   target: /api/
  #   strip_prefix: true
  #   host: mycoolwebsite.company.com
  #   priority: 250
  #   description: "API endpoints for mycoolwebsite.company.com"
  
  # # Fallback route for default domain
  # - path: /{{ app_name }}/*
  #   target: /
  #   strip_prefix: true
  #   priority: 100
  #   description: "Main endpoint on default domain"
  
  # =============================================================================
  # MIXED ROUTING (Host + Path combination)
  # =============================================================================
  # Combines hostname and path matching for granular control
  
  # - path: /special/api/*
  #   target: /special/
  #   strip_prefix: true
  #   host: api.company.com
  #   priority: 300
  #   description: "Special API endpoints on custom domain"
  
  # =============================================================================
  # ROUTING TIPS
  # =============================================================================
  # 1. Higher priority numbers take precedence (300 > 200 > 100)
  # 2. Host-based routes typically use higher priorities (200+)
  # 3. strip_prefix: false keeps the full path (useful for root routes)
  # 4. strip_prefix: true removes matched path (useful for API endpoints)
  # 5. Test your routing with: terrarium.py test
  # 6. Update /etc/hosts for custom domains:
  #    127.0.0.1 mycoolwebsite.company.com
{% endif %}

# =============================================================================
# DEPENDENCIES
# =============================================================================
# Other applications this app depends on (they will start first)
# Dependencies are started in the order they appear in this list

dependencies:
{% if dependencies %}
{% for dependency in dependencies %}
  - {{ dependency }}
{% endfor %}
{% else %}
  # No dependencies configured
  # Add dependencies like this:
  # - database
  # - redis
  # - auth-service
{% endif %}

# =============================================================================
# RESOURCE REQUIREMENTS
# =============================================================================
# CPU and memory limits for Kubernetes deployments
# These settings help Kubernetes schedule pods efficiently
# Docker Compose ignores these settings

resources:
  cpu:
    request: 100m                     # Minimum CPU allocation (100 millicores)
    limit: 200m                       # Maximum CPU allocation (200 millicores)
  memory:
    request: 128Mi                    # Minimum memory allocation (128 megabytes)
    limit: 256Mi                      # Maximum memory allocation (256 megabytes)

# =============================================================================
# HEALTH CHECKS
# =============================================================================
# Kubernetes health check configuration
# These checks ensure the application is running properly
# 
# By default, only basic port checks are enabled to avoid deployment failures
# with apps that don't implement health endpoints. Uncomment and customize
# the health checks below if your app implements proper health endpoints.

# Basic file-based health checks (enabled by default)
# These check for a running.stamp file, which works for any app
health_checks:
  # Liveness probe - checks if the app is alive using file check
  # If this fails, Kubernetes will restart the container
  liveness:
    exec:                             # Use exec command check
      command: ["test", "-f", "/tmp/running.stamp"]  # Check for running stamp file
    period_seconds: 30                # How often to check (every 30 seconds)
    timeout_seconds: 3                # How long to wait for response (3 seconds)
    failure_threshold: 3              # How many failures before restart (3 failures)
  
  # Readiness probe - checks if the app is ready using file check
  # If this fails, Kubernetes will remove the pod from service
  readiness:
    exec:                             # Use exec command check
      command: ["test", "-f", "/tmp/running.stamp"]  # Check for running stamp file
    period_seconds: 10                # How often to check (every 10 seconds)
    timeout_seconds: 3                # How long to wait for response (3 seconds)
    failure_threshold: 3              # How many failures before marking as not ready (3 failures)

# =============================================================================
# ADVANCED HEALTH CHECKS (COMMENTED OUT)
# =============================================================================
# Uncomment and use these if your app implements proper HTTP health endpoints
# Replace the health_checks section above with this configuration:

# health_checks:
#   # Liveness probe - checks if the app is alive via HTTP endpoint
#   # If this fails, Kubernetes will restart the container
#   liveness:
#     http_get:                       # Use HTTP GET request
#       path: /health                 # Endpoint to check if app is alive
#       port: {{ port }}              # Port to check
#     period_seconds: 30              # How often to check (every 30 seconds)
#     timeout_seconds: 3              # How long to wait for response (3 seconds)
#     failure_threshold: 3            # How many failures before restart (3 failures)
#   
#   # Readiness probe - checks if the app is ready via HTTP endpoint
#   # If this fails, Kubernetes will remove the pod from service
#   readiness:
#     http_get:                       # Use HTTP GET request
#       path: /health                 # Endpoint to check if app is ready
#       port: {{ port }}              # Port to check
#     period_seconds: 10              # How often to check (every 10 seconds)
#     timeout_seconds: 3              # How long to wait for response (3 seconds)
#     failure_threshold: 3            # How many failures before marking as not ready (3 failures)

# =============================================================================
# PERSISTENT VOLUMES
# =============================================================================
# Storage that persists across container restarts
# Useful for databases, file storage, and configuration files

volumes:
{% if volumes %}
{% for vol in volumes %}
  # Volume: {{ vol.name }}
  # Mount path: {{ vol.mount_path }}
  # Size: {{ vol.size }}
  # Access mode: {{ vol.access_mode }}
  - name: {{ vol.name }}
    mount_path: {{ vol.mount_path }}
    size: {{ vol.size }}
    access_mode: {{ vol.access_mode }}
{% endfor %}
{% else %}
  # No persistent volumes configured
  # Add volumes like this:
  # - name: data-volume
  #   mount_path: /app/data
  #   size: 10Gi
  #   access_mode: ReadWriteOnce
{% endif %}

# =============================================================================
# DATABASE CONFIGURATION
# =============================================================================
# Database settings for the application
# Multiple databases can be configured per application
# Database credentials are automatically generated and stored in Vault

databases:
{% if databases %}
{% for db in databases %}
  # Database: {{ db.name }}
  # Type: {{ db.type }}
  # Version: {{ db.version }}
  - enabled: {{ db.enabled | lower }}
    type: {{ db.type }}
    name: {{ db.name }}
    version: "{{ db.version }}"
    {% if db.init_scripts %}
    init_scripts:
    {% for script in db.init_scripts %}
      - {{ script }}
    {% endfor %}
    {% endif %}
    {% if db.port_forward %}
    port_forward: {{ db.port_forward }}
    {% endif %}
{% endfor %}
{% else %}
  # No databases configured
  # Add databases like this:
  # - enabled: true
  #   type: postgres
  #   name: myapp_db
  #   version: "15"
  #   init_scripts:
  #     - /app/init/schema.sql
  #     - /app/init/seed.sql
  #   port_forward: 5432
  []
{% endif %}

# =============================================================================
# SECURITY CONTEXT
# =============================================================================
# Security settings for the container
# These settings help secure the application at runtime

security:
  run_as_non_root: true               # Run container as non-root user (recommended)
  run_as_user: 1001                  # User ID to run as (must match Dockerfile)
  run_as_group: 1001                 # Group ID to run as (must match Dockerfile)
  allow_privilege_escalation: false   # Prevent privilege escalation (recommended)
  read_only_root_filesystem: false    # Allow writing to root filesystem (set to true for better security)
