# =============================================================================
# {{ app_name.title() }} Application Configuration
# =============================================================================
# This file defines how the application is deployed and configured in both 
# Docker Compose and Kubernetes (K3s) environments. It serves as the single
# source of truth for application deployment settings.
#
# Template Variables:
#   {{ app_name }} - The name of the application
#   {{ app_description }} - Description of what the application does
#   {{ image_name }} - Docker image name (will be prefixed with edge-terrarium-)
#   {{ port }} - Internal port the application listens on
#   {{ environment_vars }} - List of environment variables
#   {{ routes }} - List of API routes this app handles
#   {{ volumes }} - List of persistent volumes
#
# Important Notes:
#   - The /api/ prefix is automatically added by the ingress layer (NGINX)
#   - Routes should be defined WITHOUT the /api/ prefix
#   - All settings apply to both Docker and K3s deployments
#   - This file is processed by the terrarium CLI tool
# =============================================================================

# =============================================================================
# BASIC APPLICATION INFORMATION
# =============================================================================
# These fields identify and describe the application

# Application name - must be unique across all apps
# Used for container names, service names, and resource naming
name: {{ app_name }}

# Human-readable description of what this application does
# Used in documentation and deployment logs
description: {{ app_description }}

# =============================================================================
# DOCKER CONFIGURATION
# =============================================================================
# These settings control how the application is built and containerized
# All Docker-related settings are defined here

docker:
  # Build context directory relative to the app directory
  # Usually "." for the current directory, but can be a subdirectory
  build_context: .                    
  
  # Name of the Dockerfile to use for building
  # Can be "Dockerfile" or a custom name like "Dockerfile.prod"
  dockerfile: Dockerfile              
  
  # Docker image name (will be prefixed with edge-terrarium-)
  # Final image name will be: edge-terrarium-{{ image_name }}
  image_name: {{ image_name }}        
  
  # Docker image tag to use
  # "latest" is the default, but you can use version tags like "v1.0.0"
  tag: latest                         

# =============================================================================
# RUNTIME CONFIGURATION
# =============================================================================
# These settings control how the application runs inside containers
# Both Docker Compose and Kubernetes use these settings

runtime:
  # Internal port the application listens on inside the container
  # This should match the port your application actually uses
  port: {{ port }}                    
  
  # Health check endpoint path
  # Your application should respond to GET /health with HTTP 200
  health_check_path: /health          
  
  # Maximum time (seconds) to wait for app to start before considering it failed
  # Useful for applications that take time to initialize
  startup_timeout: 30                 

# =============================================================================
# ENVIRONMENT VARIABLES
# =============================================================================
# These variables are passed to the application at runtime
# Can include both static values and references to Vault secrets

environment:
{% if environment_vars %}
{% for env in environment_vars %}
  # Environment variable: {{ env.name }}
  # Value: {{ env.value }}
  - name: {{ env.name }}
    value: {{ env.value }}
{% endfor %}
{% else %}
  # No environment variables configured
  # Add variables like this:
  # - name: DATABASE_URL
  #   value: "postgresql://user:pass@localhost/db"
  # - name: API_KEY
  #   value_from: "vault:secret/myapp#api_key"
{% endif %}

# =============================================================================
# ROUTING CONFIGURATION
# =============================================================================
# Define how external requests are routed to this application
# The /api/ prefix is automatically added by NGINX, so define routes without it
# 
# Route Matching Rules:
#   - Routes are matched in order of specificity (most specific first)
#   - strip_prefix: true removes the matched path before forwarding to the app
#   - strip_prefix: false forwards the full path including the matched portion
#   - Use /* at the end for wildcard matching (e.g., /api/users/*)

routes:
{% if routes %}
{% for route in routes %}
  # Route: {{ route.path }} -> {{ route.target }}
  # Strip prefix: {{ route.strip_prefix | lower }}
  - path: {{ route.path }}
    target: {{ route.target }}
    strip_prefix: {{ route.strip_prefix | lower }}
{% endfor %}
{% else %}
  # No routes configured
  # Add routes like this:
  # - path: /myapp/*
  #   target: /
  #   strip_prefix: true
{% endif %}

# =============================================================================
# DEPENDENCIES
# =============================================================================
# Other applications this app depends on (they will start first)
# Dependencies are started in the order they appear in this list

dependencies:
{% if dependencies %}
{% for dependency in dependencies %}
  - {{ dependency }}
{% endfor %}
{% else %}
  # No dependencies configured
  # Add dependencies like this:
  # - database
  # - redis
  # - auth-service
{% endif %}

# =============================================================================
# RESOURCE REQUIREMENTS
# =============================================================================
# CPU and memory limits for Kubernetes deployments
# These settings help Kubernetes schedule pods efficiently
# Docker Compose ignores these settings

resources:
  cpu:
    request: 100m                     # Minimum CPU allocation (100 millicores)
    limit: 200m                       # Maximum CPU allocation (200 millicores)
  memory:
    request: 128Mi                    # Minimum memory allocation (128 megabytes)
    limit: 256Mi                      # Maximum memory allocation (256 megabytes)

# =============================================================================
# HEALTH CHECKS
# =============================================================================
# Kubernetes health check configuration
# These checks ensure the application is running properly

health_checks:
  # Liveness probe - checks if the app is alive
  # If this fails, Kubernetes will restart the container
  liveness:
    path: /health                     # Endpoint to check if app is alive
    port: {{ port }}                  # Port to check
    period_seconds: 30                # How often to check (every 30 seconds)
    timeout_seconds: 3                # How long to wait for response (3 seconds)
    failure_threshold: 3              # How many failures before restart (3 failures)
  
  # Readiness probe - checks if the app is ready to serve traffic
  # If this fails, Kubernetes will remove the pod from service
  readiness:
    path: /health                     # Endpoint to check if app is ready
    port: {{ port }}                  # Port to check
    period_seconds: 10                # How often to check (every 10 seconds)
    timeout_seconds: 3                # How long to wait for response (3 seconds)
    failure_threshold: 3              # How many failures before marking as not ready (3 failures)

# =============================================================================
# PERSISTENT VOLUMES
# =============================================================================
# Storage that persists across container restarts
# Useful for databases, file storage, and configuration files

volumes:
{% if volumes %}
{% for vol in volumes %}
  # Volume: {{ vol.name }}
  # Mount path: {{ vol.mount_path }}
  # Size: {{ vol.size }}
  # Access mode: {{ vol.access_mode }}
  - name: {{ vol.name }}
    mount_path: {{ vol.mount_path }}
    size: {{ vol.size }}
    access_mode: {{ vol.access_mode }}
{% endfor %}
{% else %}
  # No persistent volumes configured
  # Add volumes like this:
  # - name: data-volume
  #   mount_path: /app/data
  #   size: 10Gi
  #   access_mode: ReadWriteOnce
{% endif %}

# =============================================================================
# DATABASE CONFIGURATION
# =============================================================================
# Database settings for the application
# Multiple databases can be configured per application
# Database credentials are automatically generated and stored in Vault

databases:
{% if databases %}
{% for db in databases %}
  # Database: {{ db.name }}
  # Type: {{ db.type }}
  # Version: {{ db.version }}
  - enabled: {{ db.enabled | lower }}
    type: {{ db.type }}
    name: {{ db.name }}
    version: "{{ db.version }}"
    {% if db.init_scripts %}
    init_scripts:
    {% for script in db.init_scripts %}
      - {{ script }}
    {% endfor %}
    {% endif %}
    {% if db.port_forward %}
    port_forward: {{ db.port_forward }}
    {% endif %}
{% endfor %}
{% else %}
  # No databases configured
  # Add databases like this:
  # - enabled: true
  #   type: postgres
  #   name: myapp_db
  #   version: "15"
  #   init_scripts:
  #     - /app/init/schema.sql
  #     - /app/init/seed.sql
  #   port_forward: 5432
  []
{% endif %}

# =============================================================================
# SECURITY CONTEXT
# =============================================================================
# Security settings for the container
# These settings help secure the application at runtime

security:
  run_as_non_root: true               # Run container as non-root user (recommended)
  run_as_user: 1001                  # User ID to run as (must match Dockerfile)
  run_as_group: 1001                 # Group ID to run as (must match Dockerfile)
  allow_privilege_escalation: false   # Prevent privilege escalation (recommended)
  read_only_root_filesystem: false    # Allow writing to root filesystem (set to true for better security)
