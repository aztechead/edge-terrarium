# {{ app_name }}

{{ app_description }}

## Overview

This is a Python FastAPI application that's part of the Dynamic Microservices Platform. It's automatically configured for deployment in both Docker Compose and Kubernetes (K3s) environments.

## Quick Start

1. **Add your source code** to the `src/` directory
2. **Update `requirements.txt`** with your Python dependencies
3. **Update `main.py`** with your FastAPI application code
4. **Build the image**: `terrarium.py build`
5. **Deploy all apps**: `terrarium.py deploy`

## Python Dependencies

The application uses the following Python dependencies (defined in `requirements.txt`):

```
fastapi>=0.104.0
uvicorn[standard]>=0.24.0
```

### Adding Dependencies

To add new dependencies, edit `requirements.txt`:

```bash
# Add a new dependency
echo "requests>=2.31.0" >> requirements.txt

# Add a development dependency
echo "pytest>=7.0.0" >> requirements.txt

# Rebuild the image
terrarium.py build
```

## FastAPI Application

The main application code is in `main.py`. Here's the basic structure:

```python
#!/usr/bin/env python3
"""
{{ app_name }} - {{ app_description }}
"""

import asyncio
from fastapi import FastAPI

# Create FastAPI application instance
app = FastAPI(title="{{ app_name }}")

# Root endpoint
@app.get("/")
async def root():
    return {"message": "Hello from {{ app_name }}!"}

# Health check endpoint (required for platform integration)
@app.get("/health")
async def health():
    return {"status": "healthy"}

# Background task for continuous output
async def hello_task():
    """Background task that prints hello message every 5 seconds."""
    while True:
        print(f"Hello from {{ app_name }}")
        await asyncio.sleep(5)

# Start background task when app starts
@app.on_event("startup")
async def startup_event():
    """Start the hello task when the app starts."""
    asyncio.create_task(hello_task())

# Run the application
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port={{ port }})
```

### FastAPI Features

This template includes:

- **Automatic API documentation** at `/docs` and `/redoc`
- **Background tasks** for continuous logging
- **Health check endpoint** for platform monitoring
- **Async/await support** for high performance
- **Automatic request validation** and serialization

## Development Workflow

### 1. Local Development
```bash
# Install dependencies locally (optional)
pip install -r requirements.txt

# Run the application locally
python main.py

# Or use uvicorn directly
uvicorn main:app --host 0.0.0.0 --port {{ port }} --reload
```

### 2. Container Development
```bash
# Build the application image
terrarium.py build

# Deploy to Docker Compose for testing
terrarium.py deploy docker

# View logs
terrarium.py logs {{ app_name }}

# Run tests
terrarium.py test
```

### 3. Production Deployment
```bash
# Deploy to Kubernetes (K3s)
terrarium.py deploy k3s

# Check deployment status
terrarium.py status
```

## API Routes

{% if routes %}
This application handles the following API routes:

{% for route in routes %}
- **{{ route.path }}** â†’ {{ route.target }}
  - Strip prefix: {{ route.strip_prefix | lower }}
{% endfor %}

**Note**: The `/api/` prefix is automatically added by the NGINX ingress layer, so external requests will be prefixed accordingly.
{% else %}
- No routes configured

**To add routes**: Edit `app-config.yml` and add route definitions:
```yaml
routes:
  - path: /myapp/*
    target: /
    strip_prefix: true
```
{% endif %}

## Environment Variables

{% if environment_vars %}
This application uses the following environment variables:

{% for env in environment_vars %}
- **{{ env.name }}**: {{ env.value }}
{% endfor %}
{% else %}
- No environment variables configured

**To add environment variables**: Edit `app-config.yml` and add variable definitions:
```yaml
environment:
  - name: DATABASE_URL
    value: "postgresql://user:pass@localhost/db"
  - name: API_KEY
    value_from: "vault:secret/myapp#api_key"
```
{% endif %}

## Persistent Volumes

{% if volumes %}
This application uses the following persistent volumes:

{% for vol in volumes %}
- **{{ vol.name }}**: {{ vol.mount_path }} ({{ vol.size }}, {{ vol.access_mode }})
{% endfor %}
{% else %}
- No persistent volumes configured

**To add volumes**: Edit `app-config.yml` and add volume definitions:
```yaml
volumes:
  - name: data-volume
    mount_path: /app/data
    size: 10Gi
    access_mode: ReadWriteOnce
```
{% endif %}

## FastAPI Best Practices

### 1. Request/Response Models
```python
from pydantic import BaseModel

class Item(BaseModel):
    name: str
    description: str = None
    price: float
    tax: float = None

@app.post("/items/")
async def create_item(item: Item):
    return item
```

### 2. Error Handling
```python
from fastapi import HTTPException

@app.get("/items/{item_id}")
async def read_item(item_id: int):
    if item_id < 0:
        raise HTTPException(status_code=400, detail="Item ID must be positive")
    return {"item_id": item_id}
```

### 3. Background Tasks
```python
from fastapi import BackgroundTasks

def send_notification(email: str, message: str):
    # Send email notification
    pass

@app.post("/send-notification/{email}")
async def send_notification_endpoint(email: str, background_tasks: BackgroundTasks):
    background_tasks.add_task(send_notification, email, "Hello!")
    return {"message": "Notification sent"}
```

## Health Checks

This application provides health check endpoints for monitoring:

- **Health endpoint**: `GET /health`
- **Expected response**: HTTP 200 with `{"status": "healthy"}`
- **Check interval**: Every 30 seconds (liveness), every 10 seconds (readiness)

## Security

The application runs with the following security settings:

- **Non-root user**: Runs as user ID 1001
- **Privilege escalation**: Disabled
- **Read-only filesystem**: Disabled (can be enabled for better security)

## Troubleshooting

### Common Issues

1. **Application won't start**: Check the logs with `docker logs <container-name>`
2. **Health checks failing**: Ensure your app responds to `GET /health`
3. **Routes not working**: Verify the route configuration in `app-config.yml`
4. **Import errors**: Check that all dependencies are in `requirements.txt`

### Useful Commands

```bash
# View application logs
terrarium.py logs {{ app_name }}

# Check application status
terrarium.py status

# Rebuild and redeploy
terrarium.py build && terrarium.py deploy

# Access application directly (Docker)
docker exec -it edge-terrarium-{{ app_name }} sh

# Run Python shell in container
docker exec -it edge-terrarium-{{ app_name }} python
```

## Platform Integration

This application is automatically integrated with the platform's:

- **NGINX Gateway**: Routes external traffic to the application
- **Vault Integration**: Secure secrets management
- **Logging System**: Centralized logging via Logthon
- **Health Monitoring**: Automatic health checks and restart policies
- **Service Discovery**: Automatic service registration and discovery
