# =============================================================================
# Test-Db-App Application Configuration
# =============================================================================
# This file defines how the application is deployed and configured in both 
# Docker Compose and Kubernetes (K3s) environments. It serves as the single
# source of truth for application deployment settings.
#
# Template Variables:
#   test-db-app - The name of the application
#   Test app with database - Description of what the application does
#   edge-terrarium-test-db-app - Docker image name (will be prefixed with edge-terrarium-)
#   8080 - Internal port the application listens on
#   [] - List of environment variables
#   [{'path': '/test-db-app/*', 'target': '/', 'strip_prefix': True}] - List of API routes this app handles
#   [] - List of persistent volumes
#
# Important Notes:
#   - The /api/ prefix is automatically added by the ingress layer (NGINX)
#   - Routes should be defined WITHOUT the /api/ prefix
#   - All settings apply to both Docker and K3s deployments
#   - This file is processed by the terrarium CLI tool
# =============================================================================

# =============================================================================
# BASIC APPLICATION INFORMATION
# =============================================================================
# These fields identify and describe the application

# Application name - must be unique across all apps
# Used for container names, service names, and resource naming
name: test-db-app

# Human-readable description of what this application does
# Used in documentation and deployment logs
description: Test app with database

# =============================================================================
# DOCKER CONFIGURATION
# =============================================================================
# These settings control how the application is built and containerized
# All Docker-related settings are defined here

docker:
  # Build context directory relative to the app directory
  # Usually "." for the current directory, but can be a subdirectory
  build_context: .                    
  
  # Name of the Dockerfile to use for building
  # Can be "Dockerfile" or a custom name like "Dockerfile.prod"
  dockerfile: Dockerfile              
  
  # Docker image name (will be prefixed with edge-terrarium-)
  # Final image name will be: edge-terrarium-edge-terrarium-test-db-app
  image_name: edge-terrarium-test-db-app        
  
  # Docker image tag to use
  # "latest" is the default, but you can use version tags like "v1.0.0"
  tag: latest                         

# =============================================================================
# RUNTIME CONFIGURATION
# =============================================================================
# These settings control how the application runs inside containers
# Both Docker Compose and Kubernetes use these settings

runtime:
  # Internal port the application listens on inside the container
  # This should match the port your application actually uses
  port: 8080                    
  
  # Health check endpoint path
  # Your application should respond to GET /health with HTTP 200
  health_check_path: /health          
  
  # Maximum time (seconds) to wait for app to start before considering it failed
  # Useful for applications that take time to initialize
  startup_timeout: 30                 

# =============================================================================
# ENVIRONMENT VARIABLES
# =============================================================================
# These variables are passed to the application at runtime
# Can include both static values and references to Vault secrets

environment:
  # No environment variables configured
  # Add variables like this:
  # - name: DATABASE_URL
  #   value: "postgresql://user:pass@localhost/db"
  # - name: API_KEY
  #   value_from: "vault:secret/myapp#api_key"

# =============================================================================
# ROUTING CONFIGURATION
# =============================================================================
# Define how external requests are routed to this application
# The /api/ prefix is automatically added by NGINX, so define routes without it
# 
# Route Matching Rules:
#   - Routes are matched in order of specificity (most specific first)
#   - strip_prefix: true removes the matched path before forwarding to the app
#   - strip_prefix: false forwards the full path including the matched portion
#   - Use /* at the end for wildcard matching (e.g., /api/users/*)

routes:
  # Route: /test-db-app/* -> /
  # Strip prefix: true
  - path: /test-db-app/*
    target: /
    strip_prefix: true

  - path: /db/test
    target: /db/test
    strip_prefix: true

# =============================================================================
# DEPENDENCIES
# =============================================================================
# Other applications this app depends on (they will start first)
# Dependencies are started in the order they appear in this list

dependencies:
  - test-db-app-db
  # Add other dependencies like this:
  # - redis
  # - auth-service

# =============================================================================
# RESOURCE REQUIREMENTS
# =============================================================================
# CPU and memory limits for Kubernetes deployments
# These settings help Kubernetes schedule pods efficiently
# Docker Compose ignores these settings

resources:
  cpu:
    request: 100m                     # Minimum CPU allocation (100 millicores)
    limit: 200m                       # Maximum CPU allocation (200 millicores)
  memory:
    request: 128Mi                    # Minimum memory allocation (128 megabytes)
    limit: 256Mi                      # Maximum memory allocation (256 megabytes)

# =============================================================================
# HEALTH CHECKS
# =============================================================================
# Kubernetes health check configuration
# These checks ensure the application is running properly

health_checks:
  # Liveness probe - checks if the app is alive
  # If this fails, Kubernetes will restart the container
  liveness:
    path: /health                     # Endpoint to check if app is alive
    port: 8080                  # Port to check
    period_seconds: 30                # How often to check (every 30 seconds)
    timeout_seconds: 3                # How long to wait for response (3 seconds)
    failure_threshold: 3              # How many failures before restart (3 failures)
  
  # Readiness probe - checks if the app is ready to serve traffic
  # If this fails, Kubernetes will remove the pod from service
  readiness:
    path: /health                     # Endpoint to check if app is ready
    port: 8080                  # Port to check
    period_seconds: 10                # How often to check (every 10 seconds)
    timeout_seconds: 3                # How long to wait for response (3 seconds)
    failure_threshold: 3              # How many failures before marking as not ready (3 failures)

# =============================================================================
# PERSISTENT VOLUMES
# =============================================================================
# Storage that persists across container restarts
# Useful for databases, file storage, and configuration files

volumes:
  # No persistent volumes configured
  # Add volumes like this:
  # - name: data-volume
  #   mount_path: /app/data
  #   size: 10Gi
  #   access_mode: ReadWriteOnce

# =============================================================================
# DATABASE CONFIGURATION
# =============================================================================
# Database settings for the application
# Multiple databases can be configured per application
# Database credentials are automatically generated and stored in Vault

databases:
  # Database: test_app_db
  # Type: postgres
  # Version: 15
  - enabled: true
    type: postgres
    name: test_app_db
    version: "15"
    init_scripts:
      - init/schema.sql
      - init/seed.sql
    port_forward: 30433

# =============================================================================
# TEST CONFIGURATION
# =============================================================================
# Test configuration for the application
# Defines what endpoints and HTTP methods are supported for testing

test_config:
  endpoints:
    - path: /db/test
      methods: [GET]
      description: "Database connectivity test endpoint"
    - path: /health
      methods: [GET]
      description: "Health check endpoint"
  skip_generic_tests: true

# =============================================================================
# SECURITY CONTEXT
# =============================================================================
# Security settings for the container
# These settings help secure the application at runtime

security:
  run_as_non_root: true               # Run container as non-root user (recommended)
  run_as_user: 1001                  # User ID to run as (must match Dockerfile)
  run_as_group: 1001                 # Group ID to run as (must match Dockerfile)
  allow_privilege_escalation: false   # Prevent privilege escalation (recommended)
  read_only_root_filesystem: false    # Allow writing to root filesystem (set to true for better security)